Rares Carbunaru (324CB) - Tema 1 -> (le stats sportif).

1. ThreadPool Implementation

    Am inceput prin a studia modulul app al scheletului si am observat ca prima functionalitate a serverului
care trebuie implementata este aceea de ThreadPool. Am construiy clasa avand mai multi workeri (threaduri) cat
si o coada de taskuri pe care workerii asteapta sa le execute.
TaskRunner (Worker-ul nostru) este facut intr-un while care asteapta sa se puna taskuri in coada din thread-pool.
O data puse taskuri, threadurile executa functia respectiva si stocheaza outputul intr-un fisier
cu numele <job_id>.json.

2. Data Ingestor

    Clasa aceasta gestioneaza datele din CSV. Stochez intr-un dataframe din pandas fisierul csv ca mai apoi
sa pot manipula entry-urile mult mai usor, folosindu-ma de functiile predefinite din biblioteca pandas. Be baza tabelului,
am inceput sa implementez functiile care returneaza informatia dorita, ca, mai apoi sa ne putem folosi de ele atunci cand
accesam rutele API-ului nostru.
    Am schimbat parametrii constructorului. Acesta poate primi un fisier sau direct un dataframe in pandas. Aceasta modificare a 
venit din necesitatea de a putea crea si alte Data Ingestors dintr-un dataframe pentru testare de exemplu.

3. Routes

    In aceasta parte am implementat rutele API-ului nostru. Am folosit Flask pentru a crea un API RESTful care sa ne permita
sa accesam datele din CSV. Am importat DataIngestor-ul creat de catre modul din __init__.py si am inceput sa configuram fiecare
ruta din API. Pentru fiecare ruta, am extras requestul, am extras question-ul (si/sau) state-ul (dupa caz) si am creat functia de job.
Aceasta functie de job se creeaza din functiile din DataIngestor. Apoi, dupa crearea job-ului, am dat submit la task in coada din ThreadPool,
pentru ca Workerii sa poata prelua taskul si sa-l execute eficient (intre timp server-ul nostru inca face listen si poate prelua task-uri cat timp)
job-ul respectiv este in executie.

4. Logging

    In logs/webserver.log se stochezaza log-urile server-ului nostru. Am folosit modulul logging din Python pentru a crea un logger care sa ne permita
sa urmarim activitatea server-ului. Am creat un handler care scrie log-urile in fisierul webserver.log si am configurat logger-ul in fiecare ruta si 
functie de job, pentru a putea urmari activitatea server-ului si a depista eventualele erori.
    Am folosit un formatter care sa ne permita vizualizarea timestamp-ului global, nu cel local (al masinii pe care ruleaza server-ul).

5. Unittesting

    In fisierul unittests/test_webserver.py am creat un set de teste unitare pentru a verifica functionalitatea server-ului nostru. Am folosit biblioteca unittest din Python
si am initializat clasa TestWebserver care extinde unittest.TestCase. Am creat teste pentru fiecare ruta din API, pentru a verifica daca server-ul returneaza rezultatul corect.
    Am creat eu un csv de test, care contine datele necesare pentru a verifica functionalitatea server-ului. Am calculat valorile de <expected> manual, din csv, iar apoi am verificat cu 
rezultatele date de catre functiile create in DataIngestor. Am folosit metoda assertEqual pentru a verifica daca rezultatul returnat de server este cel asteptat.
    Am mai adaugat teste de verificare a integritatii inputului, de exemplu coloane invalide, stat invalid.


Status Final

Toate cele 13 funcționalități/rute au fost implementate cu succes:

/api/states_mean
/api/state_mean
/api/best5
/api/worst5
/api/global_mean
/api/diff_from_mean
/api/state_diff_from_mean
/api/mean_by_category
/api/state_mean_by_category
/api/graceful_shutdown
/api/jobs
/api/num_jobs
/api/get_results/<job_id>
Toate testele unittests trec cu succes și au fost verificate manual și cu checkerul.